# HTTP Basic Authentication
HTTP 基本授权
#### 概念
1. 浏览器遵守HTTP协议的基本授权，老项目的内网环境应该还有人用
#### 过程
1. 客户端发起请求<br>
2. 服务器发送验证请求代码401<br>
3. 符合http1.0或者1.1的将自动弹出登入窗口，用户在此输入账号密码，请求pedding<br>
4. 输完，浏览器会把这些转base64，发到请求信息authentication里<br>
5. 服务器验证是否正确，然后将请求资源返回<br>

# session-cookie
利用服务器的session和客户端的cookies（浏览器保存在电脑的字段，请求时会自动带在请求）
#### 概念
1. 由于http请求时是是无状态的，服务器无法记录这个请求是否有来过<br>
2. 为了保存网站状态（购物车，登入），客户端首次访问时，服务端会创建session，然后保存，然后生成一个唯一的标识字符串id，种在响应头里，（可进行加密处理，服务端根据密钥解密）<br>
3. 浏览器接收到id，保存在cookiel里，下每次请求带上<br>
4. 接收请求判断id，找到session看是否合法<br>
#### 过程
1. 客户端发起请求，登入。<br>
2. 服务端接收，判断账号密码正确后，生成session，保存，生成唯一id，种在响应头里，返回给客户端<br>
3. 客户端解析响应头，保存id到cookie里，下每次带上域名下的所有cookies<br>
4. 服务端接收客户端请求解析请求头cookie里的id,找到session判断是否合法，然后返回<br>
#### 弊端
1. 生成太多session,消耗服务器内存，<br>
2. 易受csrf攻击，cookie被截获<br>

# Token验证
服务端返回的字段
#### 概念
1. 用户身份的验证方式<br>
2. 用户第一次登入后服务器生成一个token,返回给客户端<br>
3. 客户端每次请求戴上它，就无需带上账号密码<br>
4. 最简单的token,uid+时间戳+sign（签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。）<br>
#### 流程
1. 客户端正确登入<br>
2. 服务端生成token，返回token<br>
3. 客户端收到token放到cookie 或者local storage里<br>
4. 客户端下每次请求带上token<br>
5. 服务端接收判断是否正确，然后返回（失败返回401）<br>
#### 优点
1. 可避开同源策略（cookie不允许跨域）<br>
2. 避免csrf攻击<br>
3. 是无状态的，可在多个服务间共享<br>
4. 支持手机<br>
#### 缺点
1. 占带宽，正常比session大（可忽略不计）<br>
2. 性能问题，需要服务端花更多时间和性能进行解密验证，和session相比时间换空间<br>

# token和session的区别
1. token在服务端保不用保存状态，session根据id查询保存的session<br>
2. token不需要借助cookie,可保存在内存，localstorage,丰富客户端类型<br>
3. 时效性token好些，session登入时生成在登出前是一直不变的，安全低，但token可以动态改变<br>
4. token可扩展，token验证比较灵活，常用JWT,也可以基于验证机制，专门做鉴权服务，用它对多个服务做统一鉴权<br>

# Token过期和refresh Token
#### 过期
基于安全，token在一定时间内过期
#### refresh Token
过期后重新获取，就是通过refresh token，也是加密字符串，其作用和安全性都较低，所以其过期时间可以长些。

# JWT(JSON Web Tokens)
#### 概念
1. 服务器认证后，生成一个对象，返回给客户端，客户端与服务器通信时带上这个json识别身份，这样客户端就不用保存session数据了，让服务器无状态，容易扩展，但同时也不可控
#### JWT结构
* 是一个很长的字符串，中间用点分割成3个部分<br>
* Headr：部分是对象，例如{alg:"HS256",type:"JWT"},alg签名算法，typeToken类型，然后base64转为字符串<br>
* Payload：部分也是对象，用来存放实际要传递的数据，然后base64转为字符串，JWT不加密,所以别把秘密信息放这 <br>
* Signature：部分是对前面两个签名，防止被篡改。但先要指定只有服务器知道的秘钥，然后使用Header里的指定签名算法<br>
#### 特点
1. 默认不加密，但可以生成Token后用秘钥加密<br>
2. 不仅可以用于验证，也可以用于交换信息。合理使用，可以降低服务器查询数据库次数<br>
3. 最大缺点，是使用过程中无法改变。除非服务器部署了额外逻辑<br>
4. 一旦泄露，则任何人都可以有权限，所以最好设置过期时间短，重要权限再次进行认证<br>
5. 最好用https传输<br>
#### 流程
1. 登入成功，服务器根据用户id,用户名，定义好密钥，过期时间，生成token,返回客户端<br>
2. 客户端拿到token储存起来<br>
3. 下每次请求，路由带上，看有没有，没就跳转登入页。或者过期跳转登入页<br>
#### 后端主动让JWT失效
前面说过JWT一旦签发了,就不再收服务端控制了.因为它在服务端没有记录,是无状态的,是它最大的优点也是最大的缺点.这样就会造成一种不可控性.<br>
例如:如果用户修改了,那他之前未到期的token怎么废弃掉???此时服务端是没有记录的,它是不知道哪些未到期的token是被废弃了的.为了解决这个问题,其实是没有完美的方法的! 都需要后端添加状态,只是那种方法开销最小.<br>
目前常见的处理方法有:

1. 将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。<br>
2. 维护一个 token 黑名单，失效则加入黑名单中(用的比较多)。<br>
3. 在 JWT 中增加一个版本号字段，失效则改变该版本号。<br>
4. 在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。<br>

这里就简单说下第二种方法:黑名单<br>

1. 在签发的jwt中payload加入一个为随机字符的字段token_id.<br>
2. 在服务端的分布式缓存上保存一份“groupId”黑名单。如果用户的jwt重置密码等需要作废已经签发但未过期的jwt时，就将该之前用户的“token__id”存入到黑名单中。并分配给他一个新的“token__id”到token中.<br>
3.存入到黑名单中的“token__id”会设置一个过期时间.过期后“token_id”自动从黑名单中删除。<br>
4. 所有需要做JWT有效性校验的服务器，启动时访问分布式缓存. 将黑名单下载到本地内存。并且订阅分布式缓存的消息推送功能，在黑名单发生增删的时候，接收推送消息同步修改内存中的黑名单列表。<br>
5. 服务器做JWT校验的时候，除了校验过期时间，还要查询内存中的黑名单列表。若在黑名单中，则判定该JWT为失效。<br>

虽然黑名单还是做了分布式存储,但黑名单本身的体积和使用频率却很低,所以开销很小.<br>
 
# 单点登入（single Sign On）sso
目前企业业务整合法人解决方案之一
#### 概念
1. 在多个应用系统中，用户只需要登入应该就可以访问所有信任的应用系统<br>
2. 需要独立的认证中心passport，子系统登入均通过passport,成功后passport会发个令牌给子系统建立局部会话，在时间内子系统不用频繁认证，访问其他信任的子系统时，会到passport认证是否验证，然后校验令牌。通过则返回资源<br>
<img src="https://user-gold-cdn.xitu.io/2019/2/21/1690f49acf068537?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" /><br>

#### 流程
1. 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数<br>
2. sso认证中心发现用户未登录，将用户引导至登录页面<br>
3. 用户输入用户名密码提交登录申请<br>
4. sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌<br>
5. sso认证中心带着令牌跳转会最初的请求地址（系统1）<br>
6. 系统1拿到令牌，去sso认证中心校验令牌是否有效<br>
7. sso认证中心校验令牌，返回有效，注册系统1<br>
8. 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源<br>
9. 用户访问系统2的受保护资源<br>
10. 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数<br>
11. sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌<br>
12. 系统2拿到令牌，去sso认证中心校验令牌是否有效<br>
13. sso认证中心校验令牌，返回有效，注册系统2<br>
14. 系统2使用该令牌创建与用户的局部会话，返回受保护资源<br>
<img src="https://user-gold-cdn.xitu.io/2019/2/21/1690f4a13430cf2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" /><br>

#### 注销
1. 用户向系统1发起注销请求<br>
2. 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求<br>
3. sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址<br>
4. sso认证中心向所有注册系统发起注销请求<br>
5. 各注册系统接收sso认证中心的注销请求，销毁局部会话<br>
6. sso认证中心引导用户至登录页面<br>

# OAuth
OAuth即开发授权,其实和SSO比较像.它允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有QQ,微信,微博等。
